\documentclass[11pt,oneside]{article}
\usepackage[utf8]{inputenc}
\usepackage[american]{babel}
\usepackage{setspace}
\usepackage{microtype}
\usepackage{mathpazo} % Palantino font
\usepackage{mdframed}
\usepackage{minted}
  \setminted{fontsize=\small}
  \setminted{breaklines}
  \usemintedstyle{bw}
  \BeforeBeginEnvironment{minted}{\vspace{6pt}\begin{mdframed}[topline=false,rightline=false,bottomline=false,linecolor=black,linewidth=2pt]}
  \AfterEndEnvironment{minted}{\end{mdframed}}
\usepackage{xcolor}
\usepackage{graphicx}
\newcommand\dd[1]{\colorbox{gray!30}{\texttt{#1}}}
\usepackage{hyperref}
  \hypersetup{colorlinks=true,allcolors=blue!40!black}
\pagestyle{empty}
\setstretch{1.2}
\setlength{\topskip}{6pt}
\setlength{\parindent}{0pt} % indent first line
\setlength{\parskip}{6pt} % before par

\title{\includegraphics[scale=0.05]{logo.png}\\Zold: Lightweight Crypto Currency}
\author{Yegor Bugayenko\\\texttt{yegor@zold.io}}

\begin{document}
\raggedbottom
\maketitle
\begin{abstract}
Works for you?
\end{abstract}

\section{Motivation}

Bitcoin, the first decentralized digital currency, was released in
January 2009. Since then a number of similar Blockchain-based products have been
created, including Etherium, Litecoin, and others.

Zold is also a decentralized digital currency that maintains its transactions
in an unpredicable amount of zero-trust server nodes, trying to guarantee
data consistency. However, the architecture of Zold is not based on Blockchain
principles. The development of Zold was motivated by the desire to overcome
a few obvious disadvantages of existing solutions.

First, the speed of transaction processing is rather low.

Second, mining commissions are high.

Third, the technology is too complex.

Zold was created as an attempt to resolve these mentioned problems
of existing digital currencies.

\section{Principles}

\textbf{Open Source}.
Zold is a command line tool. Its entire code base is open source
and hosted at the GitHub \href{https://github.com/yegor256/zold}{yegor256/zold}
repository.

\textbf{No Trust}.
The network of communicating nodes maintains wallets of users.
Anyone can add a node to the network.
It is assumed that any node may contain corrupted data, either by mistake or intentionally.

\textbf{Proof of work}.
Each node, in order to earn trust, must invest its CPU power
and find hash suffixes, performing certain calculations.

\textbf{No General Ledger}.
There is no central ledger, each wallet has its own personal ledger.
All transactions in each ledger are confirmed by
\href{https://en.wikipedia.org/wiki/RSA_(cryptosystem)}{RSA signatures}
of their owners;

\textbf{Capacity}.
One currency unit is called ZLD.
One ZLD by convention equals to $2^{24}$ \emph{zents} (16,777,216).
All amounts are stored as signed 64-bit integers.
Thus, the technical capacity of the currency is 549,755,813,888 ZLD (half a trillion).

\textbf{Zero Wallet}.
There is no ``mining,'' the only way to get ZLD is to receive it from someone else.
The wallet with the \dd{0x00} ID belongs to the
issuer and may have a negative balance. All other wallets
may only have positive balances.

\section{Proof of Work}

The system consists of nodes (server machines), which maintain the data.
In order to guarantee data consistency among all distributed nodes
there has to be an algorithm of data segregation.
Corrupted data must be detected earlier and filtered out as quickly as possible.
Bitcoin introduced such an algorithm and called it \emph{proof of work}.

Its fundamental principle is that each block of data must have a special
number attached to it, known as \emph{nonce}, which is rather difficult to calculate,
because it requires a lot of CPU power. It is assumed that at any moment
of time the majority of nodes in the network invest their CPU power into
calculating the nonces for the data that is not corrupted. If and when for any reason
some data gets corrupted, the amount of CPU power a part of the network
decides to invest into its nonces calculation would be smaller than what
the other part of the network invests into legal data. The latter part
will quickly dominate the former and the nodes with corrupted data will
be ostracized and eventually ignored.

Zold has borrowed this principle, although modified it. We also require
our nodes to invest their CPU power into meaninless and repetative
calculations just to help us identify which part of the network they belong to:
corrupted or not. Each Zold node has to calculate its \emph{trust score},
which is as big as much CPU power the node has invested into its calculation.

Similar to Bitcoin nonces we repetatively calculate cryptographic hashes,
looking for consecutive zeros inside them. First, in order to calculate a score,
a node makes the \emph{prefix}, which consists of four parts,
separated by spaces:

\begin{enumerate}
\item The current timestamp in UTC, in \href{https://en.wikipedia.org/wiki/ISO_8601}{ISO 8601},
\item The host name or IP address, e.g. \dd{b2.zold.io},
\item The \href{https://en.wikipedia.org/wiki/Port_(computer_networking)}{TCP port} number,
\item The invoice.
\end{enumerate}

For example, the prefix may look like this:

\begin{minted}{text}
2018-05-17T03:50:59Z b2.zold.io 4096 THdonv1E@0000000000000000
\end{minted}

Then, the node attempts to append any arbitrary text, which has to match
\dd{/[a-zA-Z0-9]+/} regular expression, to the end of the prefix and calculates
\href{https://en.wikipedia.org/wiki/SHA-2}{SHA-256 hash}
of the text in the hexadecimal format. For example, this would be the prefix
with the attached \dd{117b1f} suffix:

\begin{minted}{text}
2018-05-17T03:50:59Z b2.zold.io 4096 THdonv1E@0000000000000000 117b1f
\end{minted}

The hash of this text will be:

\begin{minted}{text}
670baa704726fe2c837c5ca764202adca5ab12c9b90c94d9fb1b8d629000000
\end{minted}

The node attempts to try different sufficies until one of them produces
a hash that ends with a few tailing zeroes. The one above ends
with six zeroes
(it took three minutes to find it on 2.3GHz Intel Core i7):

When the first suffix is found, the score is 1. Then, to
increase the score by one, the next suffix has to be found, which
can be added to the first 64 characters of the previous hash
in order to obtain a new hash with trailing zeros, for example:

\begin{minted}{text}
2018-05-17T03:50:59Z b2.zold.io 4096 THdonv1E@0000000000000000 117b1f 1546e35
\end{minted}

Produces:

\begin{minted}{text}
99dcd18e4bd03004e1205437866b5b68035cc8985240ae52cbd37640a000000
\end{minted}

And so on.

The score is valid only when the starting time point is earlier than
the current time, but not earlier than 24 hours ago. The strength of the score
is the amount of the trailing zeros in the hash. In the example above the
strength is six.

\section{Wallets}

There is no central ledger in Zold.
Each user has \emph{wallets} (any number of them).
Each wallet is an ASCII-text file with the name equal to the wallet ID.
For example, the wallet in the file \dd{12345678abcdef} may include:

\begin{minted}{text}
12345678abcdef
AAAAB3NzaC1yc2EAAAADAQABAAABAQCuLuVr4Tl2sXoN5Zb7b6SKMPrVjLxb...

003a;2017-07-19T21:24:51Z;ffffffff9c0ccccd;Ui0wpLu7;98bb82c81735c4ee;For services;SKMPrVj...
003b;2017-07-19T21:25:07Z;ffffffffffa72367;xksQuJa9;98bb82c81735c4ee;For food;QCuLuVr4...
0f34;2017-07-19T21:29:11Z;0000000000647388;kkIZo09s;18bb82dd1735b6e9;-;
003c;2017-07-19T22:18:43Z;ffffffffff884733;pplIe28s;38ab8fc8e735c4fc;For programming;2sXoN5...
\end{minted}

Lines are separated by either CR or CRLF.
There is a header and a ledger, separated by an empty line.
The header includes two lines:

\begin{enumerate}
  \item Wallet ID, a 64-bit unsigned integer in hexadecimal format;
  \item Public \href{https://en.wikipedia.org/wiki/RSA_(cryptosystem)}{RSA}
    key of the wallet owner, in \href{https://en.wikipedia.org/wiki/Base64}{Base64}.
\end{enumerate}

The ledger includes transactions, one per line. Each transaction line
contains fields separated by a semi-colon:

\begin{enumerate}
  \item Transaction ID, an unsigned 16-bit integer, 4-symbols hex;
  \item Date and time, in \href{https://en.wikipedia.org/wiki/ISO_8601}{ISO 8601} format, 20 symbols;
  \item Amount, a signed 64-bit integer, 16-symbols hex;
  \item Payment prefix, 8-32 symbols;
  \item Wallet ID of the beneficiary, 16-symbols hex;
  \item Details, matching \dd{/[a-zA-Z0-9 -.]\{1,128\}/};
  \item \href{https://en.wikipedia.org/wiki/RSA_(cryptosystem)}{RSA} signature,
    684 symbols in \href{https://en.wikipedia.org/wiki/Base64}{Base64}.
\end{enumerate}

Transactions with positive amount don't have signatures.
Their IDs point to ID fields of corresponding beneficiaries' wallets.

The combination ``ID'' + ``Beneficiary'' is unique in the entire wallet.

The \href{https://en.wikipedia.org/wiki/RSA_(cryptosystem)}{RSA}
signature is calculated using the private RSA key of the
wallet and the following fields of transaction, separated by spaces:

\begin{enumerate}
  \item Wallet ID;
  \item Transaction ID, an unsigned 16-bit integer;
  \item Date and time, in ISO 8601 format;
  \item Amount, a signed 64-bit integer;
  \item Payment prefix;
  \item Wallet ID of the beneficiary;
  \item Details, matching \dd{/[a-zA-Z0-9 -.]{1,128}/}.
\end{enumerate}

For example, this text may be used as a signing input:

\begin{minted}{text}
12345678abcdef 003a 2017-07-19T21:24:51Z ffffffff9c0ccccd Ui0wpLu7 98bb82c81735c4ee For services
\end{minted}

Each transaction takes 900 symbols at most.
The maximum amount of transactions in one wallet is 65536.
Thus, a single wallet may be as big as a 59Mb text file.

\section{Taxes}

Each wallet must have to pay \emph{taxes} in order to be promoted by nodes.

The amount of taxes to be paid is calculated by the following formula:

$$X = A \times F \times T.$$

$A$ is the total age of the wallet,
which is calculated as the difference in hours between the current time
and the time of the oldest transaction in the wallet.
$T$ is the total number of transactions in the wallet.
$F$ is the fee per transaction/hour, which is equal to 7.48 zents
(a one-year-old wallet with 4096 transactions inside must pay approximately 16 ZLD taxes annually).

In order to pay taxes the owner of the wallet has to select any remote
node from the network, which has a score of 16 or more. Then, it has to
take the invoice from the score and send the payment of 1 ZLD or less
to that node. The score has to be placed into the details of the transaction,
prefixed by \dd{TAXES }. All tax payments inside a wallet must
have unique scores.

\section{Fetch and Merge}

Each node maintains a list of \emph{remote nodes} (their host names and TCP port numbers),
their scores and their availability information. When the node is just installed,
the list contains a limited amount of pre-defined addresses. The list is
updated both by user request and automatically in order to give priority
to high-score nodes and the nodes with the highest availability.
Moreover, the node adds new elements to the list retrieving them from all
available remote nodes.



\section{Push}


\section{RESTful API}

\section{Incentives}

\subsection{To Stay Online}

\subsection{To Promote Other Nodes}

Each node is supposed to promote other remote nodes via the
\dd{/remotes} RESTful entry point. What is the incentive to do that?
Why can't a node always return an empty list, expecting its clients
to always pay taxes to it?

\section{Threats}

how are you?

\end{document}
